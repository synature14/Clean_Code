# Clean 동시성 코드라는걸 어떻게 보장할까?

동시성 - what과 when 을 분리하는 전략

- **다중 스레드 코드는 올바르게 구현하기 어렵다.**
    
    만약 여러 스레드 + shared property가 어우러진다면,, 
    
    동시성 오류를 일으키는 원인을 철저히 이해하여 경계 조건(=루프 종료조건 or exit() 조건)이나 보호할 코드 영역을 찾아내 lock, 잠글필요가 없는 코드는 unlock하자.
    
    애초에 공유하는 객체 수와 범위도 최대한 줄이고 client에게 공유 상태를 관리하는 책임을 떠넘기지 말자.
    
    아래에 이어서,,
    

Q. 여러 thread를 동시에 실행하는 코드를 clean하게 어떻게 짜는가?

A. 그 전에, 먼저 동시성 코드를 짤때 주의해야하는 부분을 짚고 넘어가자. 두 개 이상의 스레드가 같은 변수를 ‘동시에 참조’할때, 해당 변수를 수정하거나 삭제하는 경우 어떤 문제가 발생할까? 의도하지 않은 값을 참조하게 될수 있다. 따라서 이러한 동시성 코드의 문제점을 방어하는 원칙부터 익히자.

Q. 그 동시성 방어 원칙이 무엇이냐?

A. 임계영역의 수를 줄이자. 객체 하나를 공유할때 두 스레드가 서로 간섭하지 못하도록 critical section을 **synchronized 키워드**로 보호하자. 또는 **자료를 캡슐화하여 공유 자료를 최대한 줄이는 것**부터 시작하자.

Q. 또 다른 방어 방법이 있는가?

A. 앞서 말한 예에서 두 개의 스레드가 하나를 ‘참조’하는 것에서 비롯된 문제이기 때문에, **객체를 공유하지 말고 복사 Copy하여 사용**하거나 **접근자로 getter만 가능케** 하는 방법도 있다. 단, 복사 비용(시간&부하)도 고려하고 이행하자.

처음부터 **독자적인 스레드,** 가능하면 다른 processor에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

**언어가 제공하는 클래스를 검토해서 thread-safe한지 확인하고 사용하자**

생산자 thread, 소비자 thread가 대기열에 정보가 있다, 빈공간이 있다는 시그널을 서로에게서 기다릴 가능성이 있으므로 이 대기열(=한정된 자원)을 잘 사용하자

Q. 또 고려할 사항이 있는가?

A. 쓰기 thread가 버퍼를 갱신하는 동안 읽기 thread가 버퍼 읽지 않게 하는 균형잡기가 필요. 오랫동안 쓰기 thread가 버퍼를 점유하면 다른 thread들이 버퍼를 기다리느라 처리율이 떨어진다.

Q. 읽기 thread - 쓰기 thread간의 요구를 적절히 만족시켜 처리율도 높이고 기아현상도 줄이는 방법은?

A. 식사하는 철학자들 이야기 인용.

Q. 그런데 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다. 그럴땐?

A. 1) 클라이언트: 클라이언트에서 첫 번째 메서드를 호출하고 마지막 메서드를 호출할 때까지 lock 유지. 2) 서버: 서버를 잠그고 모든 메서드를 호출한 후 lock을 해제 3) 잠금을 수행하는 중간 단계인 연결 서버를 사용.

Q. 임계영역 개수 줄이느라 임계영역이 하나의 거대한 크기를 유지하게 되었다. 이래도 괜찮은가?

A. Nope. 임계영역 크기가 커지고 여기저기서 synchronized문을 남발하는 코드는 결국 쓰레드를 지연시키고 부하를 가중 + thread간의 경쟁이 늘어나 프로그램 성능이 떨어지게 된다

Q. 자식 thread의 데드락으로 인하여 영원히 자식 thread를 기다리는 부모thread는  어떻게 해결하는가? 

A. 그렇다, 올바른 종료 코드는 구현하기 어렵다. 종료 코드를 개발 초기부터 고민하고 동작하게끔 구현해라. 이미 나온 알고리즘을 검토해도 좋다.

Q. 그 코드가 올바르다고 증명하는, clean한 동시성 코드라는 것을 테스트하는 방법이 있는가?

A. 사실상 불가능하다. 그럼에도 불구하고 충분한 테스트를 통해 리스크를 낮출 수 있다. 다음과 같은 지침을 고려한 테스트를 해보자.

> *1) 말이 안되는 실패는 잠정적인 thread문제로 취급하라*
> 
> 
> → 재현하기 어려운 thread 레벨의 버그를 **일회성 문제로 치부하고 무시하지 말아라.**
> 

> *2) multi-thread를 고려하지 않은 순차 코드부터 제대로 돌게 만들자*
> 
> 
> → 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라! **스레드 바깥부터 먼저 해결하자**
> 

> *3) multi-thread를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 구현하라*
> 
> 
> →다중 쓰레드를 쓰는 코드를 **thread 1개, 여러 개로 실행**하거나, **실행 도중**에 **스레드 개수를 바꿔보거나**! 테스트 코드를 **빨리/천천히/다양한 속도**로 돌려보자. 반복 테스트가 가능토록 테스트 케이스를 작성한다.
> 

> *4) multi-thread를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라*
> 
> 
> → 적절한 스레드 개수를 파악하려면 상당한 시행착오가 필요하다. 프로그램 처리율 & 효율에 따라 쓰레드 개수 조욜해보기
> 

> *5) 프로세서 수보다 많은 thread를 돌려보라*
> 
> 
> → 스레드 swaping이 잦을수록 임계영역을 빼먹은 코드나 deadlock일으키는 코드를 찾기 쉬워지니 프로세서 수보다 많은 thread를 돌려보자
> 

> *6) 다른 플랫폼에서 돌려보라*
> 
> 
> → 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행하자
> 

> *7) 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으켜보자.*
> 
> 
> → 강제로 실패를 일으키게 해보자. 코드에다 직접 wait(), sleep(), yield(), priority() 함수를 추가한다. 다만, 배포 환경이 아니라 테스트 환경에서 해당 보조 코드를 실행해보자. 
> 

```swift
func nextUrlOrNull() -> String {
	if hasNext() {
		ThreadJigglePoint.jiggle()  // 매번 thread를 다른 순서로 실행하기 위해 '무작위'로 sleep()이나 yield() 호출한다
		let url = urlGenerator.next()
		
		ThreadJigglePoint.jiggle()
		updateHasNext()

		ThreadJigglePoint.jiggle()
		return url
	}

	return nil
}
```